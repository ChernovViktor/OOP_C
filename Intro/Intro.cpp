/*
   Объектно ориентированное программирование (ООП)
   Это подход при котором программа строится из объектов
   Объект - это некая сущность, которая сущенствует в пространстве и времени
   Все объекты являются экземплярами какого либо класса или стрктуры, мы и сами являемся объектами в этом мире (объект класса мышь, объект класса телефон)
   Объекты принято классифицировать. Множетво объектов с одинаковым набором характеристик называют классом
   Характеристики объекта называют свойствами, кроме характеристик у объектов може быть еще состоянее

   Класс\структура - это синтаксическая конструкция описывающая объекты 
   класс\структура состоят из полей или членов (members) 
   Поля класса\структуры делятся на 2 типа: 

   1)переменные
   члены классов описывают характеристики объектов и его состояние

   2) методы
    определяют поведение объектов и взаимодействие их с другими объектами

    Метод - это функция внутри класса 

    Прежде чем использовать структуру или класс, их нужно создать
    Прежде чем создавать объекты, нужно создать структуру или класс


*/


#include <iostream>
using namespace std;


class Point   //описывает точку на плоскоси
{
   double x;
   double y;
public:

    double get_x()const
    {
        return x;
    }

    double get_y()const
    {
        return y;
    }

    void set_x(double x)
    {
        this->x = x;
    }
    void set_y(double y)
    {
        this->y = y;
    }
    //       Constructors
    /*
    Point()
    {
        x = y = 0;
        cout << "DefaultConstructor:\t" << this << endl;
    }
    */
    Point(double x=0, double y=0)
    {   
        this->x = x;
        this->y = y;
    }
    Point(const Point& other)    //Принимает другой существующий объект по константной ссылке
    {
        //other - это просто имя параметра
        this->x = other.x;
        this->y = other.y;
        cout << "CopyConstructor:\t" << this << endl;
    }

    ~Point()
    {
        cout << "Destructor\t" << this << endl;
    }

    //                        Metods:
    void print()
    {
        cout << "X = " << x << "\t" << "Y = " << y << endl;
    }

};

//После того как создали структуру, можно создавать ее объекты.
//Создавая структуру или класс мы создаем новый тип данных


//#define STRUCT



int main()
{
    setlocale(LC_ALL, "ru");
#ifdef STRUCT
    Point A;  //Объявление(создание) переменной A типа 'Point' (как int)
              //Создание оъекта структуры поинт 
              //Объявление объекта структуры Point
    //Объект это самая обычная переменная, но не примитивного типа, а пользовательского
    //Объект это переменная нашего типа
    //Объекты еще называют экземплярами класса или структуры
    //структуры и классы ещет называют пользовательскми типами данных
    A.x = 2;
    A.y = 3;
    cout << A.x << "\t" << A.y << endl;
    Point* pA = &A;
    cout << pA->x << "\t" << pA->y << endl;
#endif //STRUCT

    Point A(2.3,4.3);   //Constructor
    //A.set_x(2);
    //A.set_y(3);

    Point B;          //DefaultConstructor
    B.print();

    Point C = A;      //CopyConstructor
    C.print();
}


/*
             ОБРАЩЕНИЕ К ПОЛЯМ ОБЪЕКТОВ
   Для обращения к полям (членам) объектов можно использовать

   '.'   - это оператор прямого доступа (Point Operator) используется для обращения к полям объекта по имени объекта
   '->'  - это оператор косвенного доступа (Arrow Operator) используется для обращения к полям объекта по адресу объекта

             ОСНОВНЫЕ КОНЦЕПЦИИ ООП

    *Единственным отличием между классом и структурой является то, что в структуре все поля по умолчанию открытые(public),
    а в классе все поля по умолчанию закрытые(private)

    *ООП базируется на трех основных концепциях:
-----------------------------------------------------------------------------------------------------------------------------
    1) Инкапсуляция
    Это сокрытие определенной части класса от внешнего мира
    Инкапсуляция реализуется модификаторами доступа get/set - методами

     *Модификаторы доступа:

        -private: закрытые поля (члены). Эти поля доступны только внутри класса и недоступны за его пределами
         в private секции класса обязательно должны быть переменные члены класса. Это защищает их от случайной перезаписи.

        -public:  открытые поля, доступные из любого места программы. В public секции обычно размещают методы.

        -protected: Защищенные поля. Этот модификатор доступа используется только при наследовании
         protected поля доступны только внутри класса и его дочерних классов

    * Get/set методы
    
         - get (взять, получить). get-методы открывают доступ к переменным класса на чтение,
           они позволяют получить, прочитать или взять значение определенной переменной объекта.

         - set (установить, задать) set-методы открывают доступ к переменным в классе на запись.
           Они позволяют задать значение той или иной переменной. 
           Кроме того set-методы обеспечивают фильтрацию данных, 
           то есть предотвращают запись некорректных значений в переменные класса (запись некорректных знач в объ-кт)
           Фильтрация данных задается обычными "if"

         - get и set метод должен быть у каждой переменной в классе 

         - get-методы должны быть константными. Константным называется метод который не изменяет объект для которого он вызывается 

         - 'this' - это указатель на объект для которого вызывается метод
         внутри объекта невозможно узнать имя объекта, но всегда можно узнать адрес этого объекта (через 'this->')

    * ИТОГО:
         Инкапсуляция защищает наши объекты от случайной перезаписи и от записи в них некорректных значений

------------------------------------------------------------------------------------------------------------------------------
    2) Наследование ..
------------------------------------------------------------------------------------------------------------------------------
    3) Полиморфизм  ..
------------------------------------------------------------------------------------------------------------------------------

   ОСОБЫЕ МЕТОДЫ В КЛАССЕ

    В классе обязательно должны быть:

    -  конструктор - метод, который создает объект, он выделяет память под объект и инициализирует его переменные (поля)

    -  деструктор - это метод, который уничтожает объект по завершении его времени жизни
                    время жизни объекта завершается при выходе из той области видимости, в которой он объявен

            * Конструктор и деструктор называются так же как и класс, но перед деструктором ставится '~'
              Конструктор может принимать параметры, а значит его можно перегрузить, как и любую функцию,
              именно поэтому в классе может быть сколько угодно конструкторов, то есть объекты можно создавать по разному.

            * Деструктор не может принимать параметры, а значит и перегрузить его тоже нельзя, поэтому в классе только 1 деструктор
              и все объекты удаляются одинаково, независимо от того, как они были созданы

            * Конструкторы бывают с параметрами, без параметров, по умолчанию конструктор копирования и конструктор переноса
              

            *Конструктор по умолчанию - это конструктор, который может быть вызван без параметров, это может быть конструктор, не принимающий никаких пар-ов
             или же конс-ор с пар-рами, кажды параметр которого имеет значение по умолчанию.
             конструктор по умолчанию может быть неявным т.е. если в классе нет ни одного конструктора, то компилтор неявно добавит туда конструктор по умолчанию
             такой неявный конструктор по умолчанию просто выделяет память под объект и заполняет эту память мусором
             неяный конструктор по умолчанию добавяется потому что без конструктора невозможно создать объект

            *Конструктор копирования - это конструктор который копирует объект, а точнее создаваемый объект делает точной копией другого существуещего объекта
             особенно важен конструктор копирования при использовании в классе динамической памяти 
             конструктор копирования всегда принимает константную ссылку на объект нашего класса 

    -  оператор присваивания 

           
*/
